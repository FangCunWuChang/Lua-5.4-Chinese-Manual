### 2.4 - 元表和元方法  
所有的Lua值都可以具有一个元表。元表以一张普通的Lua表的形式，定义了某些事件下源值的行为。你可以通过设置元表中的固定字段，来更改值的某些行为。例如，当一个非数值的值进行加法运算时，Lua会查找在该值元表中`__add`字段中的函数。如果找到了对应的函数，则Lua将会调用该函数进行加法运算。  

元表中每个事件的键名是事件名前加上两个下划线后的字符串；相应的值被称为元值。大多数事件的元值都是一个函数，被称为元方法。在上文的示例中，键名是字符串"\_\_add"，元方法是执行加法的函数。除非另有说明，否则元方法可能是任何可调用的值——一个带有"\_\_call"元方法的函数或值。  

你可以使用*getmetatable*函数查询任何值的元表，Lua将使用原始访问查询元表中的元方法（详见rawget节）。  

你可以使用*setmetatable*函数修改表的元表。但你不能在Lua代码中修改其他值的元表，除非使用调试库（详见6.10节）。  

表和full userdata都有独立的元表，尽管多个表和userdata之间可以共用一个元表。每一类其它类型的值共用同一个元表；因此，所有的数值使用同样的元表，所有的字符串也是如此。通常的，一个值是没有元表的，但字符串库给字符串类型定义了一个元表（详见6.4节）。  

下面列出了由元表控制的运算符的详细列表。每个事件都由相应的键定义。依照惯例，Lua元表中所有的键都由两个下划线后接上小写字母组成。  

- \_\_add：加号（+）。如果加法的任一操作数不是数字，Lua将尝试调用元方法。Lua将会从第一个操作数开始查找（除非它是一个数值）；如果第一个操作数没有定义`__add`元方法，Lua将会在第二个操作数的元表中查找。如果Lua找到了相应的元方法，它将会调用元方法并将两个操作数作为两个参数传入，元方法返回的结果（多个返回值将被转换为一个值）将作为运算的结果。如果Lua最终没有找到相应的元方法，Lua将会抛出一个错误。  
- \_\_sub：减号（-）。行为与加号相似。  
- \_\_mul：乘号（\*）。行为与加号相似。  
- \_\_div：除号（/）。行为与加号相似。  
- \_\_mod：求模号（%）。行为与加号相似。  
- \_\_pow：幂指数号（^）。行为与加号相似。  
- \_\_unm：否定符号（单目-）。行为与加号相似。  
- \_\_idiv：向下取整除号（//）。行为与加号相似。  
- \_\_band：按位与符号（&）。行为与加号相似，如果任一操作数既不是整数也不是可以转换为整数的浮点数，Lua将尝试使用元方法进行运算。  
- \_\_bor：按位或符号（|）。行为与按位与符号相似。  
- \_\_bxor：按位异或符号（双目~）。行为与按位与符号相似。  
- \_\_bnot：按位非符号（单目~）。行为与按位与符号相似。  
- \_\_shl：左移位符号（<<）。行为与按位与符号相似。  
- \_\_shr：右移位符号（>>）。行为与按位与符号相似。  
- \_\_concat：串联运算符（..）。行为与加号相似，如果任一操作数既不是字符串也不是可以转换为字符串的整数，Lua将尝试使用元方法进行运算。  
- \_\_len：取长度符号（#）。如果对象不是字符串时，Lua将会尝试使用相应的元方法。如果该元方法存在，Lua将会在调用元方法的同时将对象以参数的形式传入，元方法返回的结果（多个返回值将被转换为一个值）将作为运算的结果。如果没有相应的元方法但该对象是一个表，Lua将会使用表长度运算符（详见3.4.7节）。否则，Lua将会抛出一个错误。  
- \_\_eq：相等比较符（==）。行为与加号相似，当且仅当两个同为表或同为userdata的值进行比较且二者在内存中的数据不相同时，Lua将尝试使用元方法进行运算。调用的结果通常会被转换成一个布尔值。  
- \_\_lt：小于比较符（<）。行为与加号相似。当且仅当两个操作数不同为数值或不同为字符串时，Lua将尝试使用元方法进行运算。此外，调用的结果通常会被转换成一个布尔值。  
- \_\_le：小于或等于比较符（<=）。行为与小于比较符相似。  
- \_\_index：下标运算符*table[key]*。该事件发生于*table*不是表或*key*不存在于*table*中时。该元值在*table*的元表中被查找。  
该事件的元值可以是一个函数，一张表，或者任何的具有*\_\_index*元值的值。如果该元值是一个函数，Lua将会在调用元方法的同时将*table*和*key*作为两个参数传入，元方法返回的结果（多个返回值将被转换为一个值）将作为运算的结果。否则，最终结果将会是使用*key*索引此元值的结果。此索引是常规的，不是原始的，因此可以触发另一个*\_\_index*元值。  
- \_\_newindex：索引分配符号*table[key] = value*。和index事件一样，该事件发生于*table*不是表或*key*不存在于*table*中时。该元值在*table*的元表中被查找。  
和index一样，该事件的元值可以是一个函数，一张表，或者任何的具有*\_\_newindex*元值的值。如果该元值是一个函数，Lua将会在调用元方法的同时将*table*、*key*和*value*作为三个参数传入。否则，Lua将使用相同的键和值在此元值上重复分配索引。此索引是常规的，不是原始的，因此可以触发另一个*\_\_newindex*元值。  
当调用*\_\_newindex*元值时，Lua原生的赋值将不会被执行。如果需要，在元方法中可以调用*rawset*进行赋值。  
- \_\_call：调用运算符*func(args)*。此事件发生于Lua尝试调用一个非函数值时（就是说*func*不是函数时）。该元方法在*func*的中被查找。如果该元方法存在，则会在调用的同时将*func*作为第一个参数传入，其后的一组参数即为源参数（*args*）。调用的结果即为此运算的结果。这是唯一一个允许具有多个返回值的元方法。  

除了上述列表以外，解释器还允许在元表中使用下列的键：*\_\_gc*（详见2.5.3节），*\_\_close*（详见3.3.8节），*\_\_mode*（详见2.5.4节），和*\_\_name*。（当*\_\_name*入口中包含字符串时，可能会被*tostring*或错误信息使用。）  

对于单目运算符（否定符号，取长度符号和按位与符号），元方法是使用一个虚拟的、等于第一个操作数的第二个操作数来调用和运算的。这个额外的操作数只是为了简化Lua的内部结构（通过使这些运算符的行为类似于二进制操作），在将来的版本中可能会被删除。这个额外的操作数在大多数情况下是无关紧要的。  

因为元表只是一张普通的表，因此它可以包含任意的字段，不仅仅是上面列出的那些。一些标准库中的函数（例如*tostring*）会使用一些其他的字段来实现自己的目的。  

在将表设为对象的元表之前将所有需要的元方法添加到其中是一个好习惯。特别地，*\_\_gc*元方法只有在满足上述条件时才会工作（详见2.5.3节）。当每个对象建立时立即为它设置元表也是一个好习惯。  